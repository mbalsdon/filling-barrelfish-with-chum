Operating systems are a long and historied part of computer science whose importance is hard to downplay. They serve as the backbone for all modern computing systems and play a crucial role in managing tasks such as process scheduling, memory allocation, and device communication. The significance of such a system lies in its ability to abstract away hardware complexities and ensure seamless, secure, and efficient interaction between users and the underlying computer hardware.
\\\\
Barrelfish is a research operating system that distinguishes itself by way of its unique design philosophy and innovative architecture. Unlike traditional monolithic or microkernel-based systems, Barrelfish employs a distributed multikernel approach which aims to maximize the potential of the modern multicore and multiprocessor systems over which it lies. In this paper we describe how our group designed and implemented a few of its key subsystems including physical memory management, paging, inter-process communication, and more.

\subsection{Team Structure}
The development process as an individual is relatively straightforward but often not fast enough in order to adhere to tight deadlines and larger project specifications. For this class, both factors were at play and so teamwork was necessary. We organized into a group of four and promptly discussed how work should be split up.
\\\\
Progress in the class was divided into ``Milestones" which denoted the completion of large overarching pieces of the operating system. These were further divided up into ``functionalities" that described finer-grained and sometimes parallelizable tasks which made up the whole of the Milestone. At the end of each Milestone deadline, groups were required to give a presentation on what they were able to do and how they did it. It should also be noted that on the turn of each deadline, every group member was expected to understand every part of the implemented code for that Milestone.
\\\\
Given the task/deadline structure and because we were a small group of students with oftentimes chaotic schedules, the only way by which we could significantly split work was through having one person work on code sections at a time so as to prevent merge conflicts. Allocation of work was more often than not based on who had the time for it, with individual members opting to pick up free tasks wherever possible. We also observed a rather emergent development pattern where if two members were free at the same time they would share ideas and talk through tasks with each other which we believe significantly sped up the process (in other words, a sort of online pair programming where one member was actively coding and the other was checking in to help with roadblocks). We recognize that having members opt in to tasks is not the most robust team structure since a bad actor could always simply decide to not do anything, however this is and has always been a sort of inevitability of school group projects due to a lack of any external incentives (such as getting fired).

\subsection{Tools}
Our team primarily used Discord for communication when face-to-face meetings were not possible and Git/GitHub for version control. Initially we decided to use GitHub's built in ``Project Boards" feature to keep track of, allocate, and manage tasks, however this quickly fell out of favor since the group was small enough such that we were all able to easily keep up-to-date on tasks without the use of it.
