We now have physical and virtual memory management systems running. Everything is in place to start spawning (and managing) processes, which is what we set out to do in this chapter. In Barrelfish, the way we go about this is by having another already existing process allocate space for the new process and map it according to the provided binary. This ``spawn" technique is to be contrasted with the Unix ``fork-and-exec" method wherein a ``parent" process duplicates itself and then the duplicated ``child" process replaces itself with a new binary. In terms of managing processes, we want to be able to map between unique, per-process IDs (PIDs) and metadata related to the associated process. This is a desirable feature because it allows us to do things like check what processes are running, suspend/resume processes, and more.
\\\\
Implementation steps for this Milestone were relatively linear since there were not too many design decisions to make, and the tasks were not as parallelizable compared to previous Milestones due to the bulk of work being in getting a new process to spawn. We therefore speak mostly about the sequence of steps required to spawn a new process in this chapter. Also note that, although it may seem as if concurrency (out-of-order execution steps in our system with no effect on outcome) is a problem to worry about in this Milestone, we are still only running our OS on a single core. The following implementation descriptions therefore do not account for this.

\subsection{Finding and Mapping the ELF Binary}
The first step to spawning a new process is to find the file that we want to execute (an ``ELF binary") and hand it to the new process (map it into its address space). Since Barrelfish conforms to the multiboot specification for its boot images and because no filesystem was yet available for this Milestone, the process binaries are stored in the operating system's boot image. In simpler terms, this just means that we put the processes that we want to spawn at well known locations (predefined physical memory frames) on startup. These frames include the binary's executable code as well as any default command line arguments to supply it with. The binary is then mapped into the parent process' virtual address space, as it must be able to access it in order to create the child process' mappings.

\subsubsection{Creating the CSpace}
Processes in Barrelfish expect certain capabilities to exist in well-known areas in its CSpace. This means that the next step is to construct the CSpace of the child process. This involves creating a new L1 CNode (the root) and a few required L2 CNodes (descendants of the root):
\begin{itemize}[itemsep=0pt]
    \item \textbf{Task CNode}: This contains process-specific capabilities such as ones for the dispatcher control block (containing information about the process), the frame containing process arguments, the ``early" memory used for initial memory allocations (allocating memory takes memory!), and more.
    \item \textbf{Page CNode}: This contains all of the page table capabilities of the process. Since page tables are themselves in memory, they also have associated capabilities.
    \item \textbf{Slot Alloc 0/1/2}: These contains space to store capabilities for the process' slot allocators.
\end{itemize}
Similarly to how the ELF image had to be mapped into the parent, any child capabilities that are to be invoked must also be copied into the parent's CSpace since the parent counts as a separate process from the child and thus cannot use its capabilities. Once these copies are no longer needed by the parent, they are deleted.

\subsection{Creating the VSpace}\label{m3-2}
Once the child's CSpace is set up we can set up its virtual address space (``VSpace" for short). This is necessary so that the child process has some initial memory to use, enabling it to allocate more memory for itself and subsequently manage it.
\\\\
As described in the previous section, one of the initial L2 CNodes required by the child process is the Page CNode which is where the root (L0) page table and all sub-page table (L1, L2, L3) capabilities are stored. Thus, we create the root page table, place it in the first slot of this CNode, and then allocate the remaining page tables by using a \texttt{single\_slot\_allocator} which is a slot allocator for a single L2 CNode. The rest of the VSpace setup is carried out analogously to how it was done in Milestone 2 for the initial \textit{init} process, with a difference being that any capability invocations involve copying the child capabilities into the parent's CSpace as mentioned earlier.

\subsection{Parsing the ELF binary}
Once the CSpace and VSpace of the child process is setup, the next step is to parse the executable information from the ELF binary and load it into the child's memory. Just like how the parent process copies the child's capabilities into its own CSpace in order to invoke them, the executable segments of the ELF binary must be mapped into the parent so as to further copy and modify them. Once this is done, the parent can then begin loading the segments into the child process' address space. The placement and alignment of these segments is given by additional metadata contained in the ELF. The actual loading step is carried out by the function \texttt{elf\_load} that is given to us; we simply had to implement \texttt{spawn\_elf\_allocator\_fn} which is responsible for mapping the executable segments to a given address.

\subsection{Setting up the Dispatcher}
We now need to setup the dispatcher's metadata. ``Dispatcher" is Barrelfish terminology for a process (or more technically, a ``schedulable unit"). This involves creating a capability to the dispatcher and a capability to its frame, both of which are stored in the child's CSpace (and again, copied into the parent's CSpace to invoke them). This frame stores information such as the physical core the dispatcher is to be run on, its PID, whether or not it is to be started in ``disabled" mode, etc. Dispatchers may also for some reason be stopped in lieu of another dispatcher at any time, so its associated frame must also store register state when context is switched in order for it to know where it last stopped when it starts again. Lastly, the dispatcher frame also needs to know the location of the ``global offset table" which stores all of the binary's global variables, else it would not know where they are located in memory.

\subsection{Setting up the Environment}
The final step before a process is ready to be spawned is to set up its environment. For a Barrelfish dispatcher, this includes the arguments to the binary, some initial RAM capabilities so that the process can bootstrap its own memory allocations, and any capabilities that need to be passed to the child. In terms of the arguments, this amounts to creating the frame, mapping it into both the parent and child process, and then copying the arguments into it. The RAM capabilities are then split from the parent's RAM capabilities (in our case, \textit{init}) and passed into the child's CSpace by way of the well-known \texttt{TASKCN\_SLOT\_EARLYMEM} slot in the Task CNode. Lastly, any capabilities to pass to the child are copied into the child's \texttt{ARGCN} L2 CNode. 

\subsection{Process Management}
We implemented a variety of process management functions which allow procedures to programmatically identify, pause, resume, or kill a process. Processes are identified uniquely by process ID, so we need a data structure to maintain a list of all process IDs and their respective states. Since we had already implemented a hash table for Milestone 2, it was easiest for us to repurpose it as a data structure associating process IDs with their state. Using this hash table, our process management library can efficiently look up state and other necessary metadata in order to perform operations on a process.

\subsection{Passing of Paging State to the Child Process}
Once a child process has successfully been spawned and before it can begin running any user-written code, it must perform some initialization steps so that it can access and use memory. One such step sets up the child's paging state, i.e. the means by which a process maps physical memory into its VSpace. Note however that as we described in \hyperref[m3-2]{Section 4.2}, on creation of the child's VSpace we must already have had to set up this paging state in the parent process in order to map the child's ELF segments into its VSpace. Due to this re-initialization the child does not know what has already been mapped by the parent and may try erroneously map a frame to an already-mapped memory region. In order to fix this, we want to pass this already-initialized paging state data to the child once it has successfully spawn, giving it knowledge on what already resides in its VSpace.

\subsubsection{Shared Frames Between the Parent and Child}
During the setup of the child's VSpace, the parent process creates a frame holding the child's paging state data. After initializing the child's paging state (still within the parent process), we then map this shared frame into the child process' VSpace and copy the paging state data into it. We must map this frame for the child rather than just giving the child a capability to the frame because it needs access to this data in order to perform any mappings. 
\\\\
In order for the child to find this data after it has spawned, the parent maps it to a well-known virtual address. During the child's initialization phase, the child checks if this well-known address does indeed hold valid paging state data and will make use of it instead of creating a fresh paging state for itself. Once and if the child has retrieved this paging state it no longer needs to keep the shared frame around. We copy the paging state data into its stack and unmap the frame from the child process.
\\\\
We employ a shared frame between the parent and child process for the purpose of passing paging state because at the point in Milestone 3 we don't yet have any other possible method of sharing data between processes (this changes in Milestone 4 where we develop a proper method of communication between processes). Even with an established communication protocol however, we still require the ability to self-page (available after paging state is initialized) in order to set up communication channels. A primitive and shared physical frame therefore seems to be the only way through which we can pass pre-initialized paging states from parent to child processes. 

\subsubsection{Ensuring Valid Virtual Addresses After Passing}
Simply copying data from a parent process into a frame that is then read in the child process does not work out as smoothly as we had initially hoped. The parent process' pointers reference addresses in a completely different address space from that of the child's so we must ensure that the passed paging state data will refer to valid addresses in the child's VSpace. We came up with two approaches to ensure this:
\begin{enumerate}
    \item Shared data structures and pointers between the parent and child should always refer to the same virtual address.
    \item If (1) cannot be enforced, the child's pointers must be updated to valid addresses once the process has started.
\end{enumerate}
An example of the first approach can be seen in the numerous data structures used to manage the VSpace as detailed in our \hyperref[M2]{Milestone 2}. These data structures are created for the child's paging state in the parent process during the spawning setup, so we map the frames holding these data structures and any of their accommodating buffers at the same addresses in both the parent and the child. When the child process tries to access these data structures during self-paging, its pointers will still reference mapped addresses in its VSpace.
\\\\
The second approach is necessary for data structures that use function pointers which are defined symbols in the parent's ELF image and thus are not valid in the child's VSpace. Once we are in the child process and have successfully retrieved the paging state data at the well-known address, we must update all function pointers within the paging state's data structures to refer to function addresses defined within the child's ELF image.
\\\\
There is one more step to ensure that all references in the passed paging state are valid within the child's VSpace. During creation of the child's VSpace in the parent process, we allocate a few starting page tables such that we can map in the child's ELF segments. The capabilities to these page tables all refer to a root L1 CNode existing at a CSpace address relative to the parent's CSpace. The kernel will not be able to resolve the page table's CSpace slot when we try to create a mapping, so we must now also iterate through any allocated page tables and update their associated capabilities to reference a root L1 CNode relative to the child's CSpace.

\subsubsection{Assumptions}
Using a shared frame between processes works without issue at this point of time in the Milestone where we only have one core and are running at most one thread at a time. In other words, this approach to sharing paging state data from the parent to the child is not thread-safe. In later milestones, many issues begin to arise when multiple procedures are spawning concurrently, causing the parent process to sometimes overwrite data in the shared frame before the child process has gotten the chance to read from it. It is then, that we introduce mutual exclusion to address this.
